{"version":3,"sources":["Movie.js","App.js","index.js"],"names":["Movie","year","title","summary","poster","genres","className","src","alt","map","genre","index","slice","App","state","isLoading","movies","getMovies","a","axios","get","data","setState","this","movie","id","medium_cover_image","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"+RAkCeA,MA3Bf,YAAuD,IAAvCC,EAAsC,EAAtCA,KAAMC,EAAgC,EAAhCA,MAAOC,EAAyB,EAAzBA,QAASC,EAAgB,EAAhBA,OAAQC,EAAQ,EAARA,OAC1C,OAAO,sBAAKC,UAAY,QAAjB,UACF,qBAAKC,IAAOH,EAAQI,IAAON,EAAOA,MAASA,IAC5C,sBAAKI,UAAY,aAAjB,UACE,oBAAIA,UAAY,cAAhB,SAA+BJ,IAC/B,oBAAII,UAAY,aAAhB,SAA8BL,IAC9B,oBAAIK,UAAY,SAAhB,SACGD,EAAOI,KAAI,SAACC,EAAOC,GAAR,OACZ,oBAAkBL,UAAY,eAA9B,SAA8CI,GAAnCC,QAEb,oBAAGL,UAAY,gBAAf,UAAgCH,EAAQS,MAAM,EAAE,KAAhD,gBCuOKC,G,kNA3CbC,MAAQ,CACNC,WAAW,EACXC,OAAQ,I,EAGVC,U,sBAAY,8BAAAC,EAAA,sEAE8BC,IAAMC,IAAI,4DAFxC,gBAEYJ,EAFZ,EAEFK,KAAOA,KAAOL,OAErB,EAAKM,SAAS,CAACN,SAAQD,WAAW,IAJzB,2C,kEAOVQ,KAAKN,c,+BAGG,IAAD,EACuBM,KAAKT,MAA3BC,EADD,EACCA,UAAWC,EADZ,EACYA,OACnB,OACA,yBAASV,UAAU,YAAnB,SACGS,EACC,qBAAKT,UAAU,SAAf,SACE,sBAAMA,UAAY,eAAlB,0BAGD,qBAAKA,UAAY,SAAjB,SACIU,EAAOP,KAAI,SAAAe,GAAK,OACnB,cAAC,EAAD,CAEEC,GAAID,EAAMC,GACVxB,KAAMuB,EAAMvB,KACZC,MAAOsB,EAAMtB,MACbC,QAASqB,EAAMrB,QACfC,OAAQoB,EAAME,mBACdrB,OAAQmB,EAAMnB,QANTmB,EAAMC,e,GA9BLE,IAAMC,YClMxBC,IAASC,OAAO,cAAC,IAAMC,WAAP,UAAkB,cAAC,EAAD,MAA2BC,SAASC,eAAe,W","file":"static/js/main.343fcbd4.chunk.js","sourcesContent":["import React from \"react\"\nimport PropTypes, { string } from \"prop-types\";\nimport \"./Movie.css\"\n\n//movies component는 state를 필요로 하지 않음\n// component가 state가 필요없을 경우 class component가 될 필요가 없다.\n\nfunction Movie({year, title, summary, poster, genres}){\n    return <div className = \"movie\">\n         <img src = {poster} alt = {title} title = {title} />\n        <div className = \"movie_data\">\n          <h3 className = \"movie_title\">{title}</h3>\n          <h5 className = \"movie_year\">{year}</h5>\n          <ul className = \"genres\"> \n            {genres.map((genre, index) => \n            <li key = {index} className = \"genres_genre\">{genre}</li>)} \n          </ul>\n          <p className = \"movie_summary\">{summary.slice(0,140)}...</p>\n          \n        </div>\n    </div>\n}\n\n// 우리가 얻어올 props를 찾기 시작\nMovie.propTypes = {\n    id: PropTypes.number.isRequired,\n    year: PropTypes.number.isRequired,\n    title: PropTypes.string.isRequired,\n    summary: PropTypes.string.isRequired,\n    poster: PropTypes.string.isRequired,\n    genres: PropTypes.arrayOf(PropTypes.string).isRequired\n\n}\n\nexport default Movie;","// import React from 'react';\n// import PropTypes from \"prop-types\";\n/*component : a function which returns HTML <App /> 이 component이다*/\n\n\n// // 웹사이트에 동적데이터를 추가하는 방법 / 우리가 할 것은 데이터가 있다고, 시뮬레이션하는 것이다. 데이터가 이미 API에서 왓다고 상상하고 함수를 만든다. food의 object의 array이다 \n// const foodILike = [\n//   {\n//     id: 1,\n//     name: \"Kimbap\",\n//     image: \"https://dimg.donga.com/a/660/0/90/5/ugc/CDB/29STREET/Article/5e/d8/7b/c4/5ed87bc4065ad2738236.jpg\",\n//     rating: 5\n//   },\n//   {\n//     id: 2,\n//     name: \"Chicken\",\n//     image: \"http://digitalchosun.dizzo.com/site/data/img_dir/2020/03/20/2020032080079_0.jpg\",\n//     rating: 4.5\n//   },\n//   {\n//     id: 3,\n//     name: \"Pizza\",\n//     image: \"https://img1.daumcdn.net/thumb/R720x0/?fname=https%3A%2F%2Ft1.daumcdn.net%2Fliveboard%2Fdailylife%2F84ab6c45cdb149dbba0bc4ab7ff5e15f.jpg\",\n//     rating: 4\n//   },\n//   {\n//     id: 4,\n//     name: \"Steak\",\n//     image: \"https://media1.s-nbcnews.com/j/newscms/2018_07/1318715/grilled-steak-today-tease-180216_89508b219dd455b4d43311782841f938.today-inline-large.jpg\",\n//     rating: 4.6\n//   }\n// ]\n\n// function Food( { name, img, rating }) {\n//   return (\n//   <div>\n//     <h2>I love {name}</h2>\n//     <h4>{rating}/5.0</h4>\n//     <img src={img} alt={name} />\n//   </div> \n//   );\n// }\n\n// //isRequired는 필수적인 요소라는 뜻 없으면 필수가 아니때문에 number이거나 undefined이면 통과가 되는 것\n// // propTypes는 무조건 이름을 propTypes로 적어야만 체크가 가능하다!!\n// Food.propTypes = {\n//   name: PropTypes.string.isRequired,\n//   img: PropTypes.string.isRequired,\n//   rating: PropTypes.number.isRequired\n// };\n\n// //아래 function App(): function application이 있고, HTML을 return 한다\n// // application에서 food component로 정보를 보내고, food component에서 어떻게 정보를 이용하는지 에 대해서\n// // <Food name=\"kimchi\"/> 이렇게 food 안에 name=\"kimchi\"를 넣어주는 것이\n// // 정보를전달해주는방법이다. 여기서 fav는 props kimchi는 value Food는 food component이다.\n// function App() {\n//   return  (\n//   <div> \n//     {foodILike.map(dish => (\n//       <Food \n//         key={dish.id} \n//         name={dish.name} \n//         img={dish.image} \n//         rating = {dish.rating}\n//       />\n//     ))}\n//   </div>\n//   )\n// }\n\n/* 위에는 food example이다. JSX,PROPS 위의 data들을 하드코딩한 data들이다. state는 보통 동적인 데이터와 함께 작업할때 만들어지고, 변하는data,존재하지 않는 data, 생겨났다가 사라졌다가 변경된 data, 1개인 data, 2개가 되고 0 이 되는 그런것들 이 dynamic data이다. dynamic data에는 state 가 필요하다. */\n\n// import React from 'react';\n// import PropTypes from \"prop-types\";\n\n// // function App() { \n// //   return  (\n// //   <div> \n// //     {foodILike.map(dish => (\n// //       <Food \n// //         key={dish.id} \n// //         name={dish.name} \n// //         img={dish.image} \n// //         rating = {dish.rating}\n// //       />\n// //     ))}\n// //   </div>\n// //   )\n// // }\n\n// 위에 있는 function component가 아닌 class component로 변경한다. \n// class react.component는 return을 가지고 있지 않다. function이 아니기 때문이다. 대신 render method를 가지고 있다. \n\n//Function component vs Class component\n// function은 함수이며, return을 해주며, screen에 표시된다.\n// class는 class이지만, react component로부터 확장되며, screen에 표시된다. 그것을 render(){} 안에 넣어주어야한다. \n// react는 자동적으로 모든 class component의 render method를 실행하고자한다.***\n// class component를 쓰는 이유는 class component가 state를 가지고 있기 때문이다.\n// state는 object이다. component의 data를 넣을 공간이 있으며, 이 data는 변한다. \n// state를 render(){}에 넣고 싶으면, {this.state.키이름} 아래와 같이 {this.state.count}\n// component의 data를 바꾸기 원해서, 이 작업을 하는 것이다. \n// add함수와 minus함수는 react 가아니다. Javascript code다. react와는 아무 관련이 없다. \n// JavaScript에서는 onClick이나 everlistener를 등록해야하지만\n// react는 add,minus를 쉽게 호출할 수 있는데, \n// button에 onClick이라는 prop이 기본으로 깔려있다. => react magic!!\n// 다만 여기서의 button은 HTML요소다. 누군가 click할때 this.add를 실행할 것이다. \n// this.add()는 function이다. 즉시 실행될때 사용한다. 우리는 click했을때만, function이 호출되길 원하므로,this.add로 사용한다. \n\n// class App extends React.Component{\n//   constructor(props){\n//     super(props)\n//     console.log(\"hello\")\n//   }\n//   state = {\n//     count: 0\n//   }\n//     // this.state.count = 1이라고 적으면  Do not mutate state directly. 이런에러가 뜬다,\n//     // 절대 state를 직접 변경하지 말라는 뜻이다. 그리고 동작이 전혀 먹히지 않는다.  \n//     // 왜나면 react가 render function을 refresh하지 않기 때문이다. \n//     // 이말을 즉슨, 매번 state상태를 변경할때, react가 renderfunction을 호출해서 바꿔주길 바란다는의미이다.\n//     //내가 state.count = 20이라고 하면, render function이 호출되서 그때까지 count가 20이 되길 원한다.\n//     // 어떻게 하면 호출할 수 있을까? 왜 직접 state를 변경하지 말라는 메세지를 받는걸까?\n//     // setState function을 호출하게 되면, react가 언제 setState를 호출할지 알고, 또한 내가 view를 refresh 해주길 원하는지 알고, reunder function을 refresh하길 원하는것도 안다. \n//     // 우리는 state를 바꾸면서 또, react가 어떤것이든 render함수를 통해서 refresh해주길 원한다.\n//     // this.state.count = 1 대신 this.setState로 바꿔보자\n//     //////////////////////////////////////////////\n//     // setState는 새로운 state를 취해야한다. 명심! state는 obj이기 때문에 setState는 새로운 state를 받아야한다. 명심할것!!!!!! 매순간 setState를 호출할때마다, react는 새로운 state와 함께 renderfunction을 호출한다. \n//   add = () => {\n//     //setState를 호출하면 state를 refresh하고, render()를 새로운 state와 함께 한번 더 호출한다.\n//     // 현재 값(state의 값)에서 1을 더한값 / this.state.count = 현재값\n//     // 그렇지만, 이렇게 state를 사용하는 것을 cool하지 못하다\n//     //this.setState({count: this.state.count + 1});\n//     // 그렇다면, 현재 state를 가져와 function방식으로 쓸수있도록 하자. this.state.count대신에\n//     // current(현재stater값)을 가져와서 current.count라 해준다.\n//     // 이것이 react에서 외부의 상태에 의존하지 않는 가장 좋은 방법이다.   \n//     this.setState(current => ({count: current.count + 1}))\n//     //this.setState({});\n//     //this.state.count = 1;\n//     //console.log(\"add\")\n//   };\n  \n//   minus = () => {\n//     this.setState(current => ({count: current.count - 1}));\n//     //this.setState.count = -1;\n//     //console.log(\"minus\")\n//   };\n\n//   //Component, react class component는 단순히 render말고도 더 많은 것을 가지고 있다.\n//   // life cycle method를 가지는데, life cycle method는 기본적으로\n//   // react가 component를 생성하고, 없애는 방법이다. \n//   // component가 만들어질때, render 전에 호출되는 몇가지 function이 있rh,\n//   // component가 render된 후, 호출되는 다른 function들이 존재한다. \n//   // ex) add를 클릭클릭할때, component가 update될대, 호출되는 다른 functionㅇ 있다. \n//   // mounting(태어나는것), updating(업데이트), unmoounting(component died/페이지 바꿀때)\n//   // mounting  = constructor(), static getDerivedStateFromProps() render() componentDidMout()\n//   // 호출되는 function이 하나있는 constructor(). constructor()는 JavaScript에서 class만들때, 호출된다. \n//   // Mounting은 \n//   // component가 mount될떄, 즉, screen에 표시될때, component가 website에 갈때, constructor() 하고, static getDerivedStateFromProps()를 호출하고난 후, render() 를 호출한다. render 호출후에 component가 render할때, componentDidMount()를 호출한다. componentDidMount는 '이 component는 처음 render됫어!' 라고 알려준다. console을 찍어보면 알겠지만, render()이 된후 componentDidmount()가 호출된다.\n//   //Updating은\n//   // 내가 원인이다. 무슨말이냐면, 내가 add나 minus를 클릭해서 state를 변경할때가 update이다. \n//   //component가 update될때, 호출되는 많은 function이 있는데, 그중 하나가 getDerivedStateFromProps()이다.\n//   // update는 static getDerivedStateFromProps(), shouldComponentUpdate(), render(), getsnapshotBeforeUpdate()(사용안함), componentDidUpdate() 순서다.\n//   // shouldComponentUpdate는 기본적으로 업데이트를 할지말지 결정하는 것이다. setState를 호출할때마다 발생한다. \n//   // componentDidUpdate()를 만들고 add와 minus를 클릭해보면 render가 실행되고 componentDidUpdate가 찍히는 것을 볼 수 있다. 즉, setState를 호출하면, 먼저 render를 호출한 다음 update가 원료되었으면 componentDidUpdate가 실행된다. \n//   //Unmounting은 \n//   //component가 죽울때 사용한다. 이때 componentWillUnmout를 호출할 수 있다. \n\n//   componentDidMount (){ //render됫다고 알려줘서 고마워\n//     console.log('component rendered');\n//   }\n\n//   componentDidUpdate(){ // 버튼클릭하면 seteState 호출 > renderfunction도 호출 > 그다음 updated됫다고 알림받음\n//     console.log(\"I just update!@!\")\n//   }\n\n//   componentWillUnmount(){ // component가 없어질때 호출! 다른페이지로 가거나 할때!!\n//     console.log(\"Goodbye Cruel world\")\n//   }\n\n//   render(){ // 나 render됫어!\n//     console.log(\"I'm rendering\")\n//     return (\n//     <div>\n//       <h1>The number is {this.state.count}</h1>\n//       <button onClick={this.add}>Add</button>\n//       <button onClick={this.minus}>Minus</button>\n//     </div>\n//     );\n//   }\n// }\n\n// export default App;\n\n/**********************************************************************/\n/* 위에는 component, state 연습!!!*/\n/*이제 Movie App을 만들어보자!*/\n\nimport React from 'react';\nimport axios from \"axios\";\nimport Movie from \"./Movie\";\nimport \"./App.css\"\n\nclass App extends React.Component {\n  //우선 app을 mount(생성,태어나는것)하자마자, isLoading은 기본적으로 true다\n\n  state = {\n    isLoading: true,\n    movies: []\n  };\n  // getMovies는 비동기야! 기다려야해(async)\n  getMovies = async () => {\n    // axios를 기다렸다가 계속해(await axios) / axios.get은 완료되는데 시간이 조금필요하므로 await를 넣음\n     const {data: {data: {movies}}} = await axios.get(\"https://yts-proxy.now.sh/list_movies.json?sort_by=rating\");\n     //console.log(movies)//원래는 movies.data.data.movies 이지만 es6로 위에 {data: {data: {movies}}}로 넣어줌/ 이제 이 movies를 state안에 넣는다.\n     this.setState({movies, isLoading: false})\n  }\n  componentDidMount(){//처음에 render를 하면 호출되는 life cycle method이다.\n    this.getMovies();\n  }\n\n  render (){\n    const { isLoading, movies } = this.state\n    return (\n    <section className=\"container\">\n      {isLoading ? (\n        <div className=\"loader\"> \n          <span className = \"loader__text\">Loading...</span>\n        </div>\n       ) : (\n         <div className = \"movies\">\n           { movies.map(movie => (\n          <Movie \n            key={movie.id}\n            id={movie.id}\n            year={movie.year} \n            title={movie.title} \n            summary={movie.summary} \n            poster={movie.medium_cover_image}\n            genres={movie.genres}\n          />\n         ))}\n         </div> \n        )}\n    </section>\n    );\n  }\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n//import New from './New';\n\n// New에서 New를 import하고싶다고 위에 import New fron './New';를 적고 아래 render에 <New />를 적는다고 해도 먹히지 않는다 인접한 jsx 를 가지지 않는다. 왜일까?\n// 왜냐면, react application(ReactDom.render())이 오직 1개의 component를 render해야하기 때문이다. 그리고 그 component는 App 이다. \n// 그렇다면, New를 App안에 넣어보자. App.js안에 넣으면 된다.\nReactDOM.render(<React.StrictMode><App /></React.StrictMode>,document.getElementById('root'));\n\n"],"sourceRoot":""}